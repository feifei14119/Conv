MIOpenDriver: conv -i 1 -V 0 -F 1 -s 1 -n 16 -H 28 -W 28 -c 192 -k 64 -x 1 -y 1 -t 1

***************
n_in_data_tiles = 2048
n_out_pix_tiles = 16
out_pix_tile0 = 1

NWHCK = [16, 28, 28, 192, 64]
WH(out) = [28, 28]
N_LCL_OUT_MAPS = 16
N_LCL_IN_MAPS = 192
n_in_data_tiles = 192
n_out_pix_tiles = 16
out_pix_tile0 = 1

compile options:
 -DMLO_FILTER_STRIDE0=1 -DMLO_FILTER_STRIDE1=1 
 -DMLO_N_LCL_IN_MAPS_ONCE=8 -DBATCHSIZE=16 -DH=28 -DW=28 -DC=192 -DK=64 -DMLO_N_LCL_IN_MAPS=192 -DMLO_N_INPUTS=192 -DMLO_N_OUTPUTS=64 
 -DH_out=28 -DW_out=28 -DMLO_N_IN_GROUPS=1 -DMLO_CLOOP0=24 -DMLO_CLOOP2=24 -DMLO_N_LCL_OUT_MAPS=16 -DMLO_CHEAT_SHADER_COMPILER=1 
 -DMLopen_RUNNING=1
 
***********************************************************************************************
===============================================================================================
*********************************************************************************************** 
l_wk=(64, 1, 1)			group  中 item  个数
b_wk=(784, 1, 1)		group  中 group 个数
g_wk=(50176, 1, 1)		global 中 item  个数：
每个 group 负责输入WH = 64*1，全部输入通道，和16个输出特征的计算 
每个 item  负责输入WH = 1*1，全部输入通道，和16个输出特征的计算
因此共 W*H*K*N/16 = 50176个item

外层循环：对192个输入通道循环，每次处理8个输入通道。每次读取输入WH位置上8个输入通道的数据
中层循环：对16个输出特征循环，每次调整weight指针
内层循环：对8个输入通道循环，每次读取8个weight，并做乘加
所以对于每个item：输入WH上8个通道的数据被每个外层循环reuse，读取weight每次消耗一个cacheline
每个 loop  负责输入WH = 1*1，8个输入通道的乘加，16个输出特征的计算，因此一个loop需要读取一个WH位置上8个通道的输入数据和8个通道的weight，



MIOpenConv1x1J1.cl
***************
MIOpen Forward Conv. Algorithm: 1
GPU Kernel Time Forward Conv. Elapsed: 0.096744 ms



				W = 28;		// 输入图片宽度 
				H = 28;		// 输入图片高度
MLO_N_INPUTS	C = 192;	// 输入通道数
				N = 16;		// 输入图片个数
				K = 64;		// 输出特征数
				R = 1;		// 滤波器宽度
				S = 1;		// 滤波器高度

MLO_N_LCL_IN_MAPS = 		N_LCL_IN_MAPS = 192;			// 每个CU负责计算的输入通道个数
MLO_N_LCL_OUT_MAPS = 		N_LCL_OUT_MAPS = 16;			// 每个CU负责计算的输出特征数
MLO_N_LCL_IN_MAPS_ONCE = 	N_LCL_IN_MAPS_ONCE = 8; 		// 每个CU每次循环（不展开）负责计算的输入通道个数

N_IN_GROUPS = 1;				// 所有输入通道被分到几个CU
MLO_N_OUT_GROUPS = N_OUT_GROUPS = 4;				// 一个输出像素的所有特征，分到几个CU上计算

CLOOP0 = 24;					// 用于计算输入通道个数的循环次数
CLOOP2 = 24;					// 
FIXED_WORKGROUP_SIZE = 64;		// 每个CU的线程数
imagesizeAlign = 12544;			//

MLO_IN_CHANNEL_STRIDE (H * W) = 784
MLO_IN_BATCH_STRIDE (H * W * C)
MLO_OUT_BATCH_STRIDE =  H_out * W_out * K
MLO_OUT_CHANNEL_STRIDE = H_out * W_out


pos_id： 
out_id： 目前的item是在一个batch内的第几个特征值
batch_id: 目前的item是在输出的第几个batch

    uint out_grp_block = grp_id0 % MLO_N_OUT_GROUPS;
    uint in_grp_block  = (uint)(grp_id0 / MLO_N_OUT_GROUPS) % MLO_N_IN_GROUPS; // 0
    uint grp_id0_faked = (uint)(grp_id0 / MLO_N_OUT_GROUPS) / MLO_N_IN_GROUPS; // gid_x << 2

	uint pos = (grp_id0_faked * FIXED_WORKGROUP_SIZE + local_id0) % MLO_IN_CHANNEL_STRIDE;
	uint out_id = out_grp_block * MLO_N_LCL_OUT_MAPS;
	uint batch_id = (grp_id0_faked * FIXED_WORKGROUP_SIZE + local_id0) / MLO_IN_CHANNEL_STRIDE;
	
	uint wei_off = out_id * MLO_WEI_CHANNEL_STRIDE + in_grp_block * MLO_N_LCL_IN_MAPS;
	uint gbl_in_off  = batch_id * MLO_IN_BATCH_STRIDE + in_grp_block * MLO_N_LCL_IN_MAPS * MLO_IN_CHANNEL_STRIDE + pos;
    uint gbl_out_off = batch_id * MLO_OUT_BATCH_STRIDE + out_id * MLO_OUT_CHANNEL_STRIDE + pos;

	
	/***********************************************************/
	输出地址计算： 
	uint pos_id = tid + ( gid_x / MLO_N_OUT_GROUPS) * FIXED_WORKGROUP_SIZE;
	uint out_id = gid_x % MLO_N_OUT_GROUPS * MLO_N_LCL_OUT_MAPS;
	uint batch_id = gid_x / GROUPS_PER_OUT_BATCH;
	uint gbl_out_off = batch_id * MLO_OUT_BATCH_STRIDE + out_id * MLO_OUT_CHANNEL_STRIDE + pos_id;
	